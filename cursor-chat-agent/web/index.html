<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Cursor Chat Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/web/main.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <div id="chat">
    <div class="chat-header">
      <h2>Cursor IDE Chat</h2>
      <div class="status-indicator">
        <div class="status-dot"></div>
        <span id="status">Verbunden</span>
      </div>
    </div>

    <div id="messages"></div>

    <div class="typing-indicator" id="typingIndicator">
      <div class="message-avatar">AI</div>
      <div class="message-bubble">
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      </div>
    </div>

    <div class="input-area">
      <div class="input-container">
        <textarea 
          id="msgInput" 
          placeholder="Nachricht eingeben..." 
          autocomplete="off"
          rows="1"
        ></textarea>
        <div class="button-group">
          <button id="sendBtn" class="btn btn-primary">
            <span>Senden</span>
          </button>
          <button id="debugBtn" class="btn btn-secondary">
            <span>Debug</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // WebSocket connection for live reloading
    let ws;
    function connectWebSocket() {
      // Connect to dev server for live reloading
      ws = new WebSocket('ws://localhost:3001');
      
      ws.onopen = () => {
        console.log('[WebSocket] Connected for live reload');
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'reload') {
          console.log('[WebSocket] Reloading page...', data.file);
          window.location.reload();
        }
      };
      
      ws.onclose = () => {
        console.log('[WebSocket] Connection closed, attempting to reconnect...');
        setTimeout(connectWebSocket, 1000);
      };
      
      ws.onerror = (error) => {
        console.error('[WebSocket] Error:', error);
      };
    }
    
    // Connect WebSocket on page load
    connectWebSocket();

    // WebSocket connection for chat live updates
    let chatWs;
    function connectChatWebSocket() {
      chatWs = new WebSocket('ws://localhost:3001');
      chatWs.onopen = () => {
        console.log('[WebSocket] Connected for chat updates');
      };
      chatWs.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'chatUpdate') {
          console.log('[WebSocket] Chat update received');
          loadMessages();
        }
      };
      chatWs.onclose = () => {
        console.log('[WebSocket] Chat WebSocket closed, reconnecting...');
        setTimeout(connectChatWebSocket, 1000);
      };
      chatWs.onerror = (error) => {
        console.error('[WebSocket] Chat WebSocket error:', error);
      };
    }
    connectChatWebSocket();

    let lastAiContent = '';
    let aiTypingTimeout;
    let lastMessageCount = 0;
    let lastMessages = [];
    let lastMessageHash = '';
    let shouldAutoScroll = true;
    let isUserScrolling = false;
    let scrollTimeout;
    
    // Copy-Button für Codeblöcke
    function addCopyButtons() {
      document.querySelectorAll('.codeblock-copy-btn').forEach(btn => {
        btn.onclick = function() {
          const code = btn.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code);
          btn.textContent = 'Kopiert!';
          setTimeout(() => { btn.textContent = 'Copy'; }, 1200);
        };
      });
    }
    
    // Erkennung ob User-Input ein Codeblock ist
    function isUserCodeBlock(text) {
      const trimmed = text.trim();
      return (trimmed.startsWith('```') && trimmed.endsWith('```')) ||
             (/^[ \t]*[a-zA-Z0-9_\-\.]+ ?= ?.+$/m.test(trimmed)) ||
             (/^[ \t]*((if|for|while|def|class|function|let|const|var)\b|#include|import |public |private |protected )/m.test(trimmed));
    }
    
    // Hash-Funktion für Nachrichtenvergleich
    function hashMessages(messages) {
      return messages.map(m => {
        if (typeof m === 'object' && m.type && m.content) {
          return `${m.type}:${m.content}`;
        }
        return m.toString().trim();
      }).join('|');
    }
    
    // Scroll-Handler für bessere UX
    function handleScroll() {
      const msgDiv = document.getElementById('messages');
      const isAtBottom = msgDiv.scrollTop + msgDiv.clientHeight >= msgDiv.scrollHeight - 10;
      shouldAutoScroll = isAtBottom;
      
      if (isUserScrolling) {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          isUserScrolling = false;
        }, 150);
      }
    }
    
    // Smooth scroll to bottom
    function scrollToBottom(smooth = true) {
      const msgDiv = document.getElementById('messages');
      if (!shouldAutoScroll) return;
      if (smooth) {
        msgDiv.scrollTo({
          top: msgDiv.scrollHeight,
          behavior: 'smooth'
        });
      } else {
        msgDiv.scrollTop = msgDiv.scrollHeight;
      }
    }
    
    async function loadMessages() {
      try {
        const res = await fetch('/api/chat/history');
        const data = await res.json();
        let messages = [];
        if (data.messages) {
          messages = data.messages;
        } else if (data.data && data.data.messages) {
          messages = data.data.messages;
        } else {
          messages = [];
        }
        const realMessages = messages.filter(m => {
          if (typeof m === 'object' && m.type && m.content) return true;
          const msg = m.toString().trim();
          return !msg.startsWith('[Web]') && !msg.startsWith('Debug') && !msg.startsWith('Fehler') && !msg.startsWith('Error') && !Array.isArray(msg) && msg.length > 0;
        });
        const currentHash = hashMessages(realMessages);
        if (currentHash !== lastMessageHash) {
          lastMessageHash = currentHash;
        }
        const msgDiv = document.getElementById('messages');
        // Nur wenn sich die Nachrichtenanzahl ändert, DOM neu bauen
        if (msgDiv.childElementCount === 0 || realMessages.length !== lastMessages.length) {
          msgDiv.innerHTML = '';
          realMessages.forEach((msg, i) => {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${msg.type}`;
            messageEl.dataset.index = i;
            const avatarEl = document.createElement('div');
            avatarEl.className = 'message-avatar';
            avatarEl.textContent = msg.type === 'user' ? 'U' : 'AI';
            const bubbleEl = document.createElement('div');
            bubbleEl.className = 'message-bubble';
            if (msg.type === 'user' && isUserCodeBlock(msg.content)) {
              const codeBlock = document.createElement('pre');
              codeBlock.className = 'user-codeblock';
              const code = document.createElement('code');
              code.textContent = msg.content.replace(/^```[a-zA-Z0-9]*|```$/g, '').trim();
              codeBlock.appendChild(code);
              const copyBtn = document.createElement('button');
              copyBtn.className = 'codeblock-copy-btn';
              copyBtn.textContent = 'Copy';
              codeBlock.appendChild(copyBtn);
              messageEl.appendChild(codeBlock);
            } else if (msg.type === 'user') {
              bubbleEl.textContent = msg.content;
              messageEl.appendChild(bubbleEl);
            } else {
              bubbleEl.innerHTML = marked.parse(msg.content);
              bubbleEl.querySelectorAll('pre code').forEach(code => {
                const btn = document.createElement('button');
                btn.className = 'codeblock-copy-btn';
                btn.textContent = 'Copy';
                code.parentElement.style.position = 'relative';
                code.parentElement.appendChild(btn);
              });
              messageEl.appendChild(bubbleEl);
            }
            messageEl.appendChild(avatarEl);
            msgDiv.appendChild(messageEl);
          });
          requestAnimationFrame(() => {
            hljs.highlightAll();
            addCopyButtons();
            if (shouldAutoScroll) scrollToBottom(true);
          });
        } else {
          // Nur die letzte AI-Nachricht patchen
          const lastMsg = realMessages[realMessages.length - 1];
          const lastDom = msgDiv.lastElementChild;
          if (lastMsg && lastMsg.type === 'ai' && lastDom && lastDom.classList.contains('ai')) {
            const bubble = lastDom.querySelector('.message-bubble');
            if (bubble && lastMsg.content !== lastAiContent) {
              bubble.innerHTML = marked.parse(lastMsg.content);
              bubble.querySelectorAll('pre code').forEach(code => {
                const btn = document.createElement('button');
                btn.className = 'codeblock-copy-btn';
                btn.textContent = 'Copy';
                code.parentElement.style.position = 'relative';
                code.parentElement.appendChild(btn);
              });
              requestAnimationFrame(() => {
                hljs.highlightAll();
                addCopyButtons();
                if (shouldAutoScroll) scrollToBottom(true);
              });
              lastAiContent = lastMsg.content;
              if (aiTypingTimeout) clearTimeout(aiTypingTimeout);
              document.getElementById('typingIndicator').classList.add('show');
              aiTypingTimeout = setTimeout(() => {
                document.getElementById('typingIndicator').classList.remove('show');
              }, 2000);
            }
          } else {
            document.getElementById('typingIndicator').classList.remove('show');
          }
        }
        lastMessageCount = realMessages.length;
        lastMessages = realMessages;
      } catch (e) {
        document.getElementById('status').textContent = 'Fehler';
        const msgDiv = document.getElementById('messages');
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.innerHTML = `<span>⚠️</span><span>Fehler beim Laden der Nachrichten: ${e.message}</span>`;
        msgDiv.appendChild(errorEl);
      }
    }
    
    async function sendMessage() {
      const input = document.getElementById('msgInput');
      const btn = document.getElementById('sendBtn');
      const typingIndicator = document.getElementById('typingIndicator');
      const msg = input.value.trim();
      if (!msg) return;
      
      btn.disabled = true;
      input.disabled = true;
      
      try {
        console.log('[Web] Sende Nachricht:', msg);
        
        // Zeige Typing Indicator
        typingIndicator.classList.add('show');
        
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: msg })
        });
        
        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Failed to send message');
        }
        
        input.value = '';
        btn.disabled = false;
        input.disabled = false;
        typingIndicator.classList.remove('show');
        input.focus();
        
        // Force scroll to bottom after sending
        shouldAutoScroll = true;
        setTimeout(() => scrollToBottom(true), 100);
        
        // Warte 3 Sekunden bevor Chat-Historie neu geladen wird
        setTimeout(loadMessages, 3000);
      
      } catch (e) {
        console.error('[Web] Fehler beim Senden:', e);
        btn.disabled = false;
        input.disabled = false;
        typingIndicator.classList.remove('show');
        input.focus();
        
        // Zeige Fehlermeldung
        const msgDiv = document.getElementById('messages');
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.innerHTML = `
          <span>⚠️</span>
          <span>Fehler beim Senden: ${e.message}</span>
        `;
        msgDiv.appendChild(errorEl);
      }
    }
    
    // Auto-resize textarea
    function autoResizeTextarea() {
      const textarea = document.getElementById('msgInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, window.innerHeight * 0.7) + 'px';
    }
    
    // Event Listeners
    document.getElementById('sendBtn').onclick = sendMessage;
    document.getElementById('msgInput').onkeydown = e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    };
    
    document.getElementById('msgInput').addEventListener('input', autoResizeTextarea);
    window.addEventListener('DOMContentLoaded', autoResizeTextarea);
    document.getElementById('msgInput').addEventListener('focus', autoResizeTextarea);
    
    // Scroll Event Listener
    document.getElementById('messages').addEventListener('scroll', () => {
      isUserScrolling = true;
      handleScroll();
    });
    
    // Debug-Funktion
    document.getElementById('debugBtn').onclick = async () => {
      try {
        console.log('[Web] Debug DOM...');
        const res = await fetch('/debug-dom');
        const data = await res.json();
        console.log('[Web] DOM-Analyse:', data);
        
        // Zeige Debug-Info in der Konsole
        alert('DOM-Analyse in der Browser-Konsole verfügbar (F12 drücken)');
      } catch (e) {
        console.error('[Web] Debug-Fehler:', e);
        alert('Debug-Fehler: ' + e.message);
      }
    };
    
    // Smart Polling - alle 2 Sekunden für Pseudo-Live-Feeling
    setInterval(loadMessages, 2000);
    loadMessages();
  </script>
</body>
</html> 