<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Cursor Chat Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="main.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <div id="chat">
    <div class="chat-header">
      <h2>Cursor IDE Chat</h2>
      <div class="status-indicator">
        <div class="status-dot"></div>
        <span id="status">Verbunden</span>
      </div>
    </div>

    <div id="messages"></div>

    <div class="typing-indicator" id="typingIndicator">
      <div class="message-avatar">AI</div>
      <div class="message-bubble">
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      </div>
    </div>

    <div class="input-area">
      <div class="input-container">
        <textarea 
          id="msgInput" 
          placeholder="Nachricht eingeben..." 
          autocomplete="off"
          rows="1"
        ></textarea>
        <div class="button-group">
          <button id="sendBtn" class="btn btn-primary">
            <span>Senden</span>
          </button>
          <button id="debugBtn" class="btn btn-secondary">
            <span>Debug</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let lastMessageCount = 0;
    let lastMessages = [];
    let lastMessageHash = '';
    let shouldAutoScroll = true;
    let isUserScrolling = false;
    let scrollTimeout;
    
    // Hash-Funktion für Nachrichtenvergleich
    function hashMessages(messages) {
      return messages.map(m => m.trim()).join('|');
    }
    
    // Scroll-Handler für bessere UX
    function handleScroll() {
      const msgDiv = document.getElementById('messages');
      const isAtBottom = msgDiv.scrollTop + msgDiv.clientHeight >= msgDiv.scrollHeight - 10;
      shouldAutoScroll = isAtBottom;
      
      if (isUserScrolling) {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          isUserScrolling = false;
        }, 150);
      }
    }
    
    // Smooth scroll to bottom
    function scrollToBottom(smooth = true) {
      const msgDiv = document.getElementById('messages');
      if (smooth) {
        msgDiv.scrollTo({
          top: msgDiv.scrollHeight,
          behavior: 'smooth'
        });
      } else {
        msgDiv.scrollTop = msgDiv.scrollHeight;
      }
    }
    
    async function loadMessages() {
      try {
        const res = await fetch('/chat-history');
        const data = await res.json();
        const messages = data.messages || [];
        
        // Filtere nur echte Nachrichten (keine Debug/Log-Nachrichten)
        const realMessages = messages.filter(m => {
          const msg = m.toString().trim();
          return !msg.startsWith('[Web]') && 
                 !msg.startsWith('Debug') && 
                 !msg.startsWith('Fehler') &&
                 !msg.startsWith('Error') &&
                 !Array.isArray(msg) &&
                 !(typeof msg === 'object') &&
                 msg.length > 0;
        });
        
        const currentHash = hashMessages(realMessages);
        
        // Nur loggen wenn sich was geändert hat
        if (currentHash !== lastMessageHash) {
          console.log('[Web] Chatverlauf geändert:', realMessages);
          lastMessageHash = currentHash;
        }
        
        const msgDiv = document.getElementById('messages');
        const statusDiv = document.getElementById('status');
        
        // Prüfe ob neue Nachrichten da sind
        const hasNewMessages = realMessages.length > lastMessageCount;
        const newMessages = realMessages.slice(lastMessageCount);
        
        if (hasNewMessages) {
          statusDiv.textContent = `Neue Nachrichten (${newMessages.length})`;
          
          // Reset status nach 3 Sekunden
          setTimeout(() => {
            statusDiv.textContent = 'Verbunden';
          }, 3000);
        }
        
        // KORREKTE LABEL-ERKENNUNG - Server liefert jetzt "User:" und "KI:" Prefixe
        function processMessages(messages) {
          return messages.map(m => {
            const text = m.toString().trim();
            if (text.startsWith('User:')) {
              return {
                type: 'user',
                content: text.substring(5).trim(),
                original: text
              };
            } else if (text.startsWith('KI:')) {
              return {
                type: 'ai',
                content: text.substring(3).trim(),
                original: text
              };
            } else {
              // Fallback für Nachrichten ohne Prefix
              return {
                type: 'ai',
                content: text,
                original: text
              };
            }
          });
        }
        
        const processedMessages = processMessages(realMessages);
        
        // Update messages mit Animation
        if (processedMessages.length !== lastMessages.length) {
          msgDiv.innerHTML = '';
          processedMessages.forEach((msg, index) => {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${msg.type}`;
            
            // Markiere neue Nachrichten
            if (index >= lastMessageCount) {
              messageEl.classList.add('new');
            }
            
            // Avatar
            const avatarEl = document.createElement('div');
            avatarEl.className = 'message-avatar';
            avatarEl.textContent = msg.type === 'user' ? 'U' : 'AI';
            
            // Bubble
            const bubbleEl = document.createElement('div');
            bubbleEl.className = 'message-bubble';
            
            // Markdown-Rendering und Syntax-Highlighting
            bubbleEl.innerHTML = marked.parse(msg.content);
            
            messageEl.appendChild(avatarEl);
            messageEl.appendChild(bubbleEl);
            msgDiv.appendChild(messageEl);
            
            // Animation für neue Nachrichten
            if (index >= lastMessageCount) {
              setTimeout(() => {
                messageEl.classList.add('show');
              }, 50 * (index - lastMessageCount + 1));
            } else {
              messageEl.classList.add('show');
            }
          });
          
          // Nach dem Einfügen Highlighting anwenden
          setTimeout(() => { hljs.highlightAll(); }, 100);
          
          // Auto-scroll nur wenn User am Bottom ist oder neue Nachrichten
          if (shouldAutoScroll || hasNewMessages) {
            setTimeout(() => scrollToBottom(true), 150);
          }
        }
        
        lastMessageCount = processedMessages.length;
        lastMessages = processedMessages;
      } catch (e) {
        console.error('[Web] Fehler beim Laden des Chatverlaufs:', e);
        document.getElementById('status').textContent = 'Fehler';
        
        // Zeige Fehlermeldung
        const msgDiv = document.getElementById('messages');
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.innerHTML = `
          <span>⚠️</span>
          <span>Fehler beim Laden der Nachrichten: ${e.message}</span>
        `;
        msgDiv.appendChild(errorEl);
      }
    }
    
    async function sendMessage() {
      const input = document.getElementById('msgInput');
      const btn = document.getElementById('sendBtn');
      const typingIndicator = document.getElementById('typingIndicator');
      const msg = input.value.trim();
      if (!msg) return;
      
      btn.disabled = true;
      input.disabled = true;
      
      try {
        console.log('[Web] Sende Nachricht:', msg);
        
        // Zeige Typing Indicator
        typingIndicator.classList.add('show');
        
        await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: msg })
        });
        
        input.value = '';
        btn.disabled = false;
        input.disabled = false;
        typingIndicator.classList.remove('show');
        
        // Force scroll to bottom after sending
        shouldAutoScroll = true;
        setTimeout(() => scrollToBottom(true), 100);
        
        // Sofort nach dem Senden laden
        setTimeout(loadMessages, 500);
      } catch (e) {
        console.error('[Web] Fehler beim Senden:', e);
        btn.disabled = false;
        input.disabled = false;
        typingIndicator.classList.remove('show');
        
        // Zeige Fehlermeldung
        const msgDiv = document.getElementById('messages');
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.innerHTML = `
          <span>⚠️</span>
          <span>Fehler beim Senden: ${e.message}</span>
        `;
        msgDiv.appendChild(errorEl);
      }
    }
    
    // Auto-resize textarea
    function autoResizeTextarea() {
      const textarea = document.getElementById('msgInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    // Event Listeners
    document.getElementById('sendBtn').onclick = sendMessage;
    document.getElementById('msgInput').onkeydown = e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    };
    
    document.getElementById('msgInput').addEventListener('input', autoResizeTextarea);
    
    // Scroll Event Listener
    document.getElementById('messages').addEventListener('scroll', () => {
      isUserScrolling = true;
      handleScroll();
    });
    
    // Debug-Funktion
    document.getElementById('debugBtn').onclick = async () => {
      try {
        console.log('[Web] Debug DOM...');
        const res = await fetch('/debug-dom');
        const data = await res.json();
        console.log('[Web] DOM-Analyse:', data);
        
        // Zeige Debug-Info in der Konsole
        alert('DOM-Analyse in der Browser-Konsole verfügbar (F12 drücken)');
      } catch (e) {
        console.error('[Web] Debug-Fehler:', e);
        alert('Debug-Fehler: ' + e.message);
      }
    };
    
    // Smart Polling - nur alle 2 Sekunden statt 1 Sekunde
    setInterval(loadMessages, 2000);
    loadMessages();
  </script>
</body>
</html> 