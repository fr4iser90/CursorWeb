<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Cursor Chat Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/web/main.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
  <div id="chat">
    <div class="chat-header">
      <h2>Cursor IDE Chat</h2>
      <div class="status-indicator">
        <div class="status-dot"></div>
        <span id="status">Verbunden</span>
      </div>
    </div>

    <div id="messages"></div>

    <div class="typing-indicator" id="typingIndicator">
      <div class="message-avatar">AI</div>
      <div class="message-bubble">
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      </div>
    </div>

    <div class="input-area">
      <div class="input-container">
        <textarea 
          id="msgInput" 
          placeholder="Nachricht eingeben..." 
          autocomplete="off"
          rows="1"
        ></textarea>
        <div class="button-group">
          <button id="sendBtn" class="btn btn-primary">
            <span>Senden</span>
          </button>
          <button id="debugBtn" class="btn btn-secondary">
            <span>Debug</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // WebSocket connection for live reloading
    let ws;
    function connectWebSocket() {
      // Connect to dev server for live reloading
      ws = new WebSocket('ws://localhost:3001');
      
      ws.onopen = () => {
        console.log('[WebSocket] Connected for live reload');
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'reload') {
          console.log('[WebSocket] Reloading page...', data.file);
          window.location.reload();
        }
      };
      
      ws.onclose = () => {
        console.log('[WebSocket] Connection closed, attempting to reconnect...');
        setTimeout(connectWebSocket, 1000);
      };
      
      ws.onerror = (error) => {
        console.error('[WebSocket] Error:', error);
      };
    }
    
    // Connect WebSocket on page load
    connectWebSocket();

    let lastMessageCount = 0;
    let lastMessages = [];
    let lastMessageHash = '';
    let shouldAutoScroll = true;
    let isUserScrolling = false;
    let scrollTimeout;
    
    // Copy-Button für Codeblöcke
    function addCopyButtons() {
      document.querySelectorAll('.codeblock-copy-btn').forEach(btn => {
        btn.onclick = function() {
          const code = btn.parentElement.querySelector('code').innerText;
          navigator.clipboard.writeText(code);
          btn.textContent = 'Kopiert!';
          setTimeout(() => { btn.textContent = 'Copy'; }, 1200);
        };
      });
    }
    
    // Erkennung ob User-Input ein Codeblock ist
    function isUserCodeBlock(text) {
      const trimmed = text.trim();
      return (trimmed.startsWith('```') && trimmed.endsWith('```')) ||
             (/^[ \t]*[a-zA-Z0-9_\-\.]+ ?= ?.+$/m.test(trimmed)) ||
             (/^[ \t]*((if|for|while|def|class|function|let|const|var)\b|#include|import |public |private |protected )/m.test(trimmed));
    }
    
    // Hash-Funktion für Nachrichtenvergleich
    function hashMessages(messages) {
      return messages.map(m => {
        if (typeof m === 'object' && m.type && m.content) {
          return `${m.type}:${m.content}`;
        }
        return m.toString().trim();
      }).join('|');
    }
    
    // Scroll-Handler für bessere UX
    function handleScroll() {
      const msgDiv = document.getElementById('messages');
      const isAtBottom = msgDiv.scrollTop + msgDiv.clientHeight >= msgDiv.scrollHeight - 10;
      shouldAutoScroll = isAtBottom;
      
      if (isUserScrolling) {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          isUserScrolling = false;
        }, 150);
      }
    }
    
    // Smooth scroll to bottom
    function scrollToBottom(smooth = true) {
      const msgDiv = document.getElementById('messages');
      if (smooth) {
        msgDiv.scrollTo({
          top: msgDiv.scrollHeight,
          behavior: 'smooth'
        });
      } else {
        msgDiv.scrollTop = msgDiv.scrollHeight;
      }
    }
    
    async function loadMessages() {
      try {
        const res = await fetch('/chat-history');
        const data = await res.json();
        
        // Handle both old and new API response formats
        let messages = [];
        if (data.messages) {
          // Old format
          messages = data.messages;
        } else if (data.data && data.data.messages) {
          // New DDD format
          messages = data.data.messages;
        } else {
          messages = [];
        }
        
        // Filtere nur echte Nachrichten (keine Debug/Log-Nachrichten)
        const realMessages = messages.filter(m => {
          // Neue Objekt-Nachrichten immer akzeptieren
          if (typeof m === 'object' && m.type && m.content) {
            return true;
          }
          
          // String-Nachrichten filtern
          const msg = m.toString().trim();
          return !msg.startsWith('[Web]') && 
                 !msg.startsWith('Debug') && 
                 !msg.startsWith('Fehler') &&
                 !msg.startsWith('Error') &&
                 !Array.isArray(msg) &&
                 msg.length > 0;
        });
        
        const currentHash = hashMessages(realMessages);
        
        // Nur loggen wenn sich was geändert hat
        if (currentHash !== lastMessageHash) {
          console.log('[Web] Chatverlauf geändert:', realMessages);
          lastMessageHash = currentHash;
        }
        
        const msgDiv = document.getElementById('messages');
        const statusDiv = document.getElementById('status');
        
        // Prüfe ob neue Nachrichten da sind
        const hasNewMessages = realMessages.length > lastMessageCount;
        const newMessages = realMessages.slice(lastMessageCount);
        
        if (hasNewMessages) {
          statusDiv.textContent = `Neue Nachrichten (${newMessages.length})`;
          
          // Reset status nach 3 Sekunden
          setTimeout(() => {
            statusDiv.textContent = 'Verbunden';
          }, 3000);
        }
        
        // KORREKTE VERARBEITUNG - Server liefert jetzt Objekte mit type und content
        function processMessages(messages) {
          return messages.map(m => {
            // Wenn es bereits ein Objekt mit type/content ist
            if (typeof m === 'object' && m.type && m.content) {
              return {
                type: m.type,
                content: m.content,
                original: m.content
              };
            }
            
            // Fallback für String-Nachrichten (alte Format)
            const text = m.toString().trim();
            if (text.startsWith('User:')) {
              return {
                type: 'user',
                content: text.substring(5).trim(),
                original: text
              };
            } else if (text.startsWith('KI:')) {
              return {
                type: 'ai',
                content: text.substring(3).trim(),
                original: text
              };
            } else {
              // Fallback für Nachrichten ohne Prefix
              return {
                type: 'ai',
                content: text,
                original: text
              };
            }
          });
        }
        
        const processedMessages = processMessages(realMessages);
        
        // Sortiere Nachrichten chronologisch (User-Nachrichten sollten nach AI-Nachrichten kommen)
        // Da wir die Nachrichten vom Server in der Reihenfolge bekommen, wie sie im DOM stehen,
        // müssen wir sie nicht extra sortieren, aber sicherstellen dass sie korrekt angezeigt werden
        
        // Update messages mit Animation
        if (processedMessages.length !== lastMessages.length) {
          msgDiv.innerHTML = '';
          processedMessages.forEach((msg, index) => {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${msg.type}`;
            
            // Markiere neue Nachrichten
            if (index >= lastMessageCount) {
              messageEl.classList.add('new');
            }
            
            // Avatar
            const avatarEl = document.createElement('div');
            avatarEl.className = 'message-avatar';
            avatarEl.textContent = msg.type === 'user' ? 'U' : 'AI';
            
            // Bubble
            const bubbleEl = document.createElement('div');
            bubbleEl.className = 'message-bubble';
            
            // USER: Codeblock oder Bubble
            if (msg.type === 'user' && isUserCodeBlock(msg.content)) {
              // User-Codeblock
              const codeBlock = document.createElement('pre');
              codeBlock.className = 'user-codeblock';
              const code = document.createElement('code');
              code.textContent = msg.content.replace(/^```[a-zA-Z0-9]*|```$/g, '').trim();
              codeBlock.appendChild(code);
              // Copy-Button
              const copyBtn = document.createElement('button');
              copyBtn.className = 'codeblock-copy-btn';
              copyBtn.textContent = 'Copy';
              codeBlock.appendChild(copyBtn);
              messageEl.appendChild(codeBlock);
            } else if (msg.type === 'user') {
              // User-Bubble - Zeige den kompletten Inhalt (inkl. "User:" prefix)
              bubbleEl.textContent = msg.content;
              messageEl.appendChild(bubbleEl);
            } else {
              // KI: Markdown + Codeblöcke mit Copy-Button
              bubbleEl.innerHTML = marked.parse(msg.content);
              // Füge Copy-Button zu jedem Codeblock hinzu
              bubbleEl.querySelectorAll('pre code').forEach(code => {
                const btn = document.createElement('button');
                btn.className = 'codeblock-copy-btn';
                btn.textContent = 'Copy';
                code.parentElement.style.position = 'relative';
                code.parentElement.appendChild(btn);
              });
              messageEl.appendChild(bubbleEl);
            }
            
            messageEl.appendChild(avatarEl);
            msgDiv.appendChild(messageEl);
            
            // Animation für neue Nachrichten
            if (index >= lastMessageCount) {
              setTimeout(() => {
                messageEl.classList.add('show');
              }, 50 * (index - lastMessageCount + 1));
            } else {
              messageEl.classList.add('show');
            }
          });
          
          // Nach dem Einfügen Highlighting anwenden
          setTimeout(() => { hljs.highlightAll(); addCopyButtons(); }, 100);
          
          // Auto-scroll nur wenn User am Bottom ist oder neue Nachrichten
          if (shouldAutoScroll || hasNewMessages) {
            setTimeout(() => scrollToBottom(true), 150);
          }
        }
        
        lastMessageCount = processedMessages.length;
        lastMessages = processedMessages;
      } catch (e) {
        console.error('[Web] Fehler beim Laden des Chatverlaufs:', e);
        document.getElementById('status').textContent = 'Fehler';
        
        // Zeige Fehlermeldung
        const msgDiv = document.getElementById('messages');
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.innerHTML = `
          <span>⚠️</span>
          <span>Fehler beim Laden der Nachrichten: ${e.message}</span>
        `;
        msgDiv.appendChild(errorEl);
      }
    }
    
    async function sendMessage() {
      const input = document.getElementById('msgInput');
      const btn = document.getElementById('sendBtn');
      const typingIndicator = document.getElementById('typingIndicator');
      const msg = input.value.trim();
      if (!msg) return;
      
      btn.disabled = true;
      input.disabled = true;
      
      try {
        console.log('[Web] Sende Nachricht:', msg);
        
        // Zeige Typing Indicator
        typingIndicator.classList.add('show');
        
        const response = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: msg })
        });
        
        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Failed to send message');
        }
        
        input.value = '';
        btn.disabled = false;
        input.disabled = false;
        typingIndicator.classList.remove('show');
        
        // Force scroll to bottom after sending
        shouldAutoScroll = true;
        setTimeout(() => scrollToBottom(true), 100);
        
        // Sofort nach dem Senden laden
        setTimeout(loadMessages, 500);
      } catch (e) {
        console.error('[Web] Fehler beim Senden:', e);
        btn.disabled = false;
        input.disabled = false;
        typingIndicator.classList.remove('show');
        
        // Zeige Fehlermeldung
        const msgDiv = document.getElementById('messages');
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.innerHTML = `
          <span>⚠️</span>
          <span>Fehler beim Senden: ${e.message}</span>
        `;
        msgDiv.appendChild(errorEl);
      }
    }
    
    // Auto-resize textarea
    function autoResizeTextarea() {
      const textarea = document.getElementById('msgInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    // Event Listeners
    document.getElementById('sendBtn').onclick = sendMessage;
    document.getElementById('msgInput').onkeydown = e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    };
    
    document.getElementById('msgInput').addEventListener('input', autoResizeTextarea);
    
    // Scroll Event Listener
    document.getElementById('messages').addEventListener('scroll', () => {
      isUserScrolling = true;
      handleScroll();
    });
    
    // Debug-Funktion
    document.getElementById('debugBtn').onclick = async () => {
      try {
        console.log('[Web] Debug DOM...');
        const res = await fetch('/debug-dom');
        const data = await res.json();
        console.log('[Web] DOM-Analyse:', data);
        
        // Zeige Debug-Info in der Konsole
        alert('DOM-Analyse in der Browser-Konsole verfügbar (F12 drücken)');
      } catch (e) {
        console.error('[Web] Debug-Fehler:', e);
        alert('Debug-Fehler: ' + e.message);
      }
    };
    
    // Smart Polling - nur alle 10 Sekunden um Fehler zu reduzieren
    setInterval(loadMessages, 10000);
    loadMessages();
  </script>
</body>
</html> 