<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDE Mirror - Cursor IDE Remote Control</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <style>
        .ide-mirror-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }

        .ide-mirror-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            flex-shrink: 0;
        }

        .toolbar-left, .toolbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn {
            padding: 6px 12px;
            background: #0e639c;
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover { background: #1177bb; }
        .btn:disabled { background: #666; cursor: not-allowed; }

        .status {
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }

        .status.connected { background: #16825d; color: white; }
        .status.disconnected { background: #a1260d; color: white; }
        .status.connecting { background: #bf8803; color: white; }

        .ide-mirror-viewport {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #252526;
        }

        .loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #333;
            border-top: 3px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mirrored-content {
            transform-origin: top left;
            min-height: 100%;
            position: relative;
        }

        .mirror-element.clickable {
            outline: 1px dashed rgba(14, 99, 156, 0.5) !important;
            cursor: pointer !important;
        }

        .mirror-element.clickable:hover {
            outline: 2px solid #0e639c !important;
            background-color: rgba(14, 99, 156, 0.1) !important;
        }

        .click-feedback {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #0e639c;
            border-radius: 50%;
            background: rgba(14, 99, 156, 0.3);
            pointer-events: none;
            animation: clickRipple 0.6s ease-out;
            z-index: 10000;
        }

        @keyframes clickRipple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        input[type="range"] { width: 100px; }
        #scaleValue { min-width: 35px; text-align: center; font-size: 11px; }
        #ideTitle { font-weight: bold; color: #cccccc; }
    </style>
</head>
<body>
    <div class="ide-mirror-container">
        <div class="ide-mirror-toolbar">
            <div class="toolbar-left">
                <button id="connectBtn" class="btn">üîå Connect IDE</button>
                <button id="refreshBtn" class="btn">üîÑ Refresh</button>
                <span id="statusIndicator" class="status disconnected">Disconnected</span>
            </div>
            <div class="toolbar-center">
                <span id="ideTitle">IDE Mirror</span>
            </div>
            <div class="toolbar-right">
                <label>
                    <input type="checkbox" id="showClickableOnly"> Clickable Only
                </label>
                <input type="range" id="scaleSlider" min="0.3" max="1.5" step="0.1" value="1">
                <span id="scaleValue">100%</span>
                <select id="ideSelector">
                    <option value="">Select IDE...</option>
                </select>
            </div>
        </div>
        <div class="ide-mirror-viewport" id="mirrorViewport">
            <div class="loading-message">
                <div class="loading-spinner"></div>
                <p>Click "Connect IDE" to start mirroring...</p>
            </div>
        </div>
    </div>

    <script>
        class IDEMirrorApp {
            constructor() {
                this.ws = null;
                this.currentState = null;
                this.isConnected = false;
                this.config = {
                    showClickableOnly: false,
                    scale: 1
                };
                
                this.init();
            }

            init() {
                this.setupEventHandlers();
                this.connectWebSocket();
                this.loadAvailableIDEs();
                
                // Auto-connect to IDE after a short delay
                setTimeout(() => {
                    this.connectToIDE();
                }, 1000);
            }

            setupEventHandlers() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connectToIDE());
                document.getElementById('refreshBtn').addEventListener('click', () => this.refreshIDE());
                
                document.getElementById('showClickableOnly').addEventListener('change', (e) => {
                    this.config.showClickableOnly = e.target.checked;
                    this.renderMirroredContent();
                });

                const scaleSlider = document.getElementById('scaleSlider');
                scaleSlider.addEventListener('input', (e) => {
                    this.config.scale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = Math.round(this.config.scale * 100) + '%';
                    this.updateScale();
                });

                document.getElementById('ideSelector').addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.switchToIDE(e.target.value);
                    }
                });
            }

            connectWebSocket() {
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${location.host}`;
                
                console.log('üîå Connecting to WebSocket:', wsUrl);
                this.updateStatus('connecting', 'Connecting...');
                
                // Show connecting message in viewport
                document.getElementById('mirrorViewport').innerHTML = `
                    <div class="loading-message">
                        <div class="loading-spinner"></div>
                        <p>Connecting to WebSocket...</p>
                    </div>
                `;

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('‚úÖ WebSocket connected');
                    this.isConnected = true;
                    this.updateStatus('connected', 'Connected');
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleWebSocketMessage(message);
                    } catch (error) {
                        console.error('‚ùå Failed to parse WebSocket message:', error);
                    }
                };

                this.ws.onclose = () => {
                    console.log('üîå WebSocket disconnected');
                    this.isConnected = false;
                    this.updateStatus('disconnected', 'Disconnected');
                    this.ws = null;
                    
                    // Attempt to reconnect after 3 seconds
                    setTimeout(() => this.connectWebSocket(), 3000);
                };

                this.ws.onerror = (error) => {
                    console.error('‚ùå WebSocket error:', error);
                    this.updateStatus('disconnected', 'Connection Error');
                };
            }

            handleWebSocketMessage(message) {
                console.log('üì• Received WebSocket message:', message);
                const { type, data } = message;

                switch (type) {
                    case 'ide-state-updated':
                        console.log('üîÑ IDE state updated, rendering...', data);
                        this.updateIDEState(data);
                        break;
                    case 'ide-connected':
                        console.log('‚úÖ IDE connected, rendering state...', data);
                        this.updateIDEState(data);
                        break;
                    case 'error':
                        console.error('‚ùå IDE Mirror error:', message.message || message.error);
                        document.getElementById('mirrorViewport').innerHTML = `
                            <div class="loading-message">
                                <p>‚ùå Error: ${message.message || message.error}</p>
                                <button onclick="window.ideMirror.connectToIDE()" class="btn">Retry</button>
                            </div>
                        `;
                        break;
                    default:
                        console.log('üì¢ Unknown message type:', type, message);
                }
            }

            async loadAvailableIDEs() {
                try {
                    const response = await fetch('/api/ide-mirror/ides');
                    const result = await response.json();
                    
                    if (result.success) {
                        this.updateIDESelector(result.data);
                    }
                } catch (error) {
                    console.log('Available IDEs will be loaded after connection');
                }
            }

            updateIDESelector(ides) {
                const selector = document.getElementById('ideSelector');
                selector.innerHTML = '<option value="">Select IDE...</option>';
                
                ides.forEach(ide => {
                    const option = document.createElement('option');
                    option.value = ide.port;
                    option.textContent = `Port ${ide.port} - ${ide.status}`;
                    if (ide.status === 'active') {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            }

            updateIDEState(state) {
                this.currentState = state;
                this.renderMirroredContent();
                
                if (state.title) {
                    document.getElementById('ideTitle').textContent = `${state.title} (Port: ${state.idePort || 'unknown'})`;
                }
                
                console.log(`üîÑ IDE state updated - ${new Date(state.timestamp).toLocaleTimeString()}`);
            }

            renderMirroredContent() {
                if (!this.currentState) return;

                const viewport = document.getElementById('mirrorViewport');
                
                try {
                    const mirroredHTML = this.generateMirrorHTML(this.currentState.body);
                    
                    viewport.innerHTML = `
                        <div class="mirrored-content" style="transform: scale(${this.config.scale});">
                            ${mirroredHTML}
                        </div>
                    `;

                    this.attachClickHandlers();
                    
                } catch (error) {
                    console.error('‚ùå Failed to render mirrored content:', error);
                    viewport.innerHTML = `
                        <div class="loading-message">
                            <p>‚ùå Failed to render IDE content</p>
                            <button onclick="window.ideMirror.refreshIDE()" class="btn">Try Again</button>
                        </div>
                    `;
                }
            }

            generateMirrorHTML(elementData) {
                if (!elementData) return '';

                const { tagName, id, className, textContent, style, position, isClickable, isVisible, children } = elementData;

                if (!isVisible && !isClickable) return '';
                
                if (this.config.showClickableOnly && !isClickable) {
                    return children.map(child => this.generateMirrorHTML(child)).join('');
                }

                const styleStr = Object.entries(style || {})
                    .map(([key, value]) => `${key.replace(/([A-Z])/g, '-$1').toLowerCase()}: ${value}`)
                    .join('; ');

                let attrs = '';
                if (id) attrs += ` id="mirror-${id}"`;
                attrs += ` class="mirror-element ${className} ${isClickable ? 'clickable' : ''}"`;
                
                if (isClickable) {
                    attrs += ` data-selector="${elementData.selector}"`;
                    attrs += ` data-position='${JSON.stringify(position)}'`;
                }

                const childrenHTML = children.map(child => this.generateMirrorHTML(child)).join('');
                const safeText = textContent ? textContent.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';

                if (['img', 'br', 'hr', 'input', 'meta', 'link'].includes(tagName)) {
                    return `<${tagName}${attrs} style="${styleStr}" />`;
                }

                if (children.length > 0) {
                    return `<${tagName}${attrs} style="${styleStr}">${childrenHTML}</${tagName}>`;
                } else {
                    return `<${tagName}${attrs} style="${styleStr}">${safeText}</${tagName}>`;
                }
            }

            attachClickHandlers() {
                const clickableElements = document.querySelectorAll('.mirror-element.clickable');
                
                clickableElements.forEach(element => {
                    element.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const selector = element.getAttribute('data-selector');
                        const position = JSON.parse(element.getAttribute('data-position') || '{}');
                        
                        this.handleElementClick(selector, position, e);
                    });
                });
            }

            handleElementClick(selector, position, event) {
                if (!this.isConnected) {
                    this.showMessage('Not connected to WebSocket');
                    return;
                }

                console.log(`üñ±Ô∏è Clicking element: ${selector}`, position);
                this.showClickFeedback(event.clientX, event.clientY);

                this.ws.send(JSON.stringify({
                    type: 'click-element',
                    payload: { selector, coordinates: position }
                }));
            }

            showClickFeedback(x, y) {
                const feedback = document.createElement('div');
                feedback.className = 'click-feedback';
                feedback.style.left = (x - 10) + 'px';
                feedback.style.top = (y - 10) + 'px';
                
                document.body.appendChild(feedback);
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 600);
            }

            connectToIDE() {
                if (!this.isConnected) {
                    console.log('‚ùå WebSocket not connected, trying to connect...');
                    this.showMessage('WebSocket not connected, retrying...');
                    this.connectWebSocket();
                    return;
                }

                console.log('üîå Sending connect-ide message to backend...');
                document.getElementById('mirrorViewport').innerHTML = `
                    <div class="loading-message">
                        <div class="loading-spinner"></div>
                        <p>Connecting to Cursor IDE...</p>
                    </div>
                `;
                
                this.ws.send(JSON.stringify({ type: 'connect-ide' }));
                this.showMessage('Connecting to IDE...');
            }

            refreshIDE() {
                if (!this.isConnected) {
                    this.connectWebSocket();
                    return;
                }

                this.ws.send(JSON.stringify({ type: 'refresh-ide' }));
                this.showMessage('Refreshing IDE state...');
            }

            switchToIDE(port) {
                if (!this.isConnected) {
                    this.showMessage('WebSocket not connected');
                    return;
                }

                this.ws.send(JSON.stringify({ 
                    type: 'switch-ide',
                    payload: { port: parseInt(port) }
                }));
                this.showMessage(`Switching to IDE on port ${port}...`);
            }

            updateScale() {
                const mirroredContent = document.querySelector('.mirrored-content');
                if (mirroredContent) {
                    mirroredContent.style.transform = `scale(${this.config.scale})`;
                }
            }

            updateStatus(type, text) {
                const indicator = document.getElementById('statusIndicator');
                if (indicator) {
                    indicator.className = `status ${type}`;
                    indicator.textContent = text;
                }
            }

            showMessage(message) {
                console.log(`üì¢ ${message}`);
                // Could add toast notifications here
            }
        }

        // Initialize the IDE Mirror
        window.ideMirror = new IDEMirrorApp();
    </script>
</body>
</html> 