const Task = require('../entities/Task');
const TaskStatus = require('../value-objects/TaskStatus');
const TaskPriority = require('../value-objects/TaskPriority');
const TaskType = require('../value-objects/TaskType');

/**
 * TaskService - Business logic for project-based task management
 */
class TaskService {
  constructor(taskRepository, aiService, projectAnalyzer) {
    this.taskRepository = taskRepository;
    this.aiService = aiService;
    this.projectAnalyzer = projectAnalyzer;
  }

  /**
   * Create a new task for a project
   * @param {string} projectId - Project ID
   * @param {string} title - Task title
   * @param {string} description - Task description
   * @param {string} priority - Task priority
   * @param {string} type - Task type
   * @param {Object} metadata - Additional metadata
   * @returns {Promise<Task>} Created task
   */
  async createTask(projectId, title, description, priority = TaskPriority.MEDIUM, type = TaskType.FEATURE, metadata = {}) {
    if (!projectId) {
      throw new Error('Project ID is required');
    }

    if (!title || title.trim().length === 0) {
      throw new Error('Task title is required');
    }

    const task = Task.create(projectId, title, description, priority, type, metadata);
    return await this.taskRepository.create(task);
  }

  /**
   * Update an existing task
   * @param {string} taskId - Task ID
   * @param {Object} updates - Update data
   * @returns {Promise<Task>} Updated task
   */
  async updateTask(taskId, updates) {
    const task = await this.taskRepository.findById(taskId);
    if (!task) {
      throw new Error('Task not found');
    }

    if (updates.title) {
      task.title = updates.title;
    }
    if (updates.description) {
      task.description = updates.description;
    }
    if (updates.status && TaskStatus.isValid(updates.status)) {
      task.updateStatus(updates.status);
    }
    if (updates.priority && TaskPriority.isValid(updates.priority)) {
      task.updatePriority(updates.priority);
    }
    if (updates.metadata) {
      task.updateMetadata(updates.metadata);
    }

    return await this.taskRepository.update(taskId, task);
  }

  /**
   * Execute a task
   * @param {string} taskId - Task ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} Execution result
   */
  async executeTask(taskId, userId) {
    console.log('üîç [TaskService] executeTask called with:', { taskId, userId });
    
    try {
      const task = await this.taskRepository.findById(taskId);
      if (!task) {
        throw new Error('Task not found');
      }

      console.log('üîç [TaskService] Found task:', task);

      if (task.isCompleted()) {
        throw new Error('Task is already completed');
      }

      // Update task status to in progress
      task.updateStatus(TaskStatus.IN_PROGRESS);
      await this.taskRepository.update(taskId, task);

      console.log('üîç [TaskService] Task status updated to in progress');

      // REAL AI EXECUTION - Create tasks.md and send to Cursor IDE
      const execution = {
        taskId,
        userId,
        status: 'running',
        startedAt: new Date(),
        progress: 0
      };

      // Create tasks.md content for Cursor IDE
      const tasksMdContent = `# Task Execution: ${task.title}

## Task Details
- **ID**: ${task.id}
- **Title**: ${task.title}
- **Description**: ${task.description}
- **Type**: ${task.type}
- **Priority**: ${task.priority}
- **Status**: ${task.status}

## Instructions
Please execute this task in Cursor IDE:

${task.description}

## Expected Outcome
Complete the task and provide a summary of what was accomplished.

## Task Metadata
- Created by: ${task.metadata.createdBy}
- Created at: ${task.createdAt}
- Project: ${task.projectId}

---
*This task was generated by the CursorWeb Task Management System*
`;

      console.log('üîç [TaskService] Creating tasks.md for Cursor IDE...');
      console.log('üìù [TaskService] Tasks.md content:', tasksMdContent);

      // Send to Cursor IDE via Playwright
      try {
        // This would integrate with the existing CursorIDEService
        // For now, we'll create a file that you can manually open in Cursor
        const fs = require('fs');
        const path = require('path');
        
        const tasksFilePath = path.join(process.cwd(), 'tasks.md');
        fs.writeFileSync(tasksFilePath, tasksMdContent);
        
        console.log('‚úÖ [TaskService] Created tasks.md at:', tasksFilePath);
        console.log('üîç [TaskService] Please open this file in Cursor IDE and execute the task');
        
        // In real implementation, this would:
        // 1. Use CursorIDEService to open the file in Cursor
        // 2. Monitor the execution
        // 3. Wait for completion
        // 4. Update task status based on result
        
        // For now, we'll simulate completion after a delay
        setTimeout(async () => {
          try {
            task.updateStatus(TaskStatus.COMPLETED);
            task.setMetadata('executionResult', {
              completedAt: new Date(),
              method: 'manual_execution',
              notes: 'Task executed manually in Cursor IDE'
            });
            await this.taskRepository.update(taskId, task);
            console.log('‚úÖ [TaskService] Task completed successfully');
          } catch (error) {
            console.error('‚ùå [TaskService] Error completing task:', error);
          }
        }, 10000); // 10 seconds for manual execution
        
      } catch (error) {
        console.error('‚ùå [TaskService] Error creating tasks.md:', error);
        task.updateStatus(TaskStatus.FAILED);
        await this.taskRepository.update(taskId, task);
        throw error;
      }

      console.log('‚úÖ [TaskService] Task execution started');
      return execution;
    } catch (error) {
      console.error('‚ùå [TaskService] Error in executeTask:', error);
      throw error;
    }
  }

  /**
   * Get task execution status
   * @param {string} taskId - Task ID
   * @returns {Promise<Object>} Execution status
   */
  async getTaskExecution(taskId) {
    const task = await this.taskRepository.findById(taskId);
    if (!task) {
      throw new Error('Task not found');
    }

    return {
      taskId,
      status: task.status,
      progress: task.isCompleted() ? 100 : 50,
      startedAt: task.createdAt,
      completedAt: task.completedAt
    };
  }

  /**
   * Cancel task execution
   * @param {string} taskId - Task ID
   * @param {string} userId - User ID
   * @returns {Promise<boolean>} Success status
   */
  async cancelTask(taskId, userId) {
    const task = await this.taskRepository.findById(taskId);
    if (!task) {
      throw new Error('Task not found');
    }

    if (task.isCompleted()) {
      throw new Error('Cannot cancel completed task');
    }

    task.updateStatus(TaskStatus.CANCELLED);
    await this.taskRepository.update(taskId, task);

    return true;
  }

  /**
   * Analyze project and generate tasks
   * @param {string} projectId - Project ID
   * @param {string} projectPath - Project path
   * @param {Object} options - Analysis options
   * @returns {Promise<Object>} Analysis results
   */
  async analyzeProjectAndGenerateTasks(projectId, projectPath, options = {}) {
    // Analyze project structure
    const projectAnalysis = await this.projectAnalyzer.analyzeProject(projectPath);
    
    // Generate AI-powered suggestions
    const aiSuggestions = await this.aiService.generateTaskSuggestions(projectAnalysis, options);
    
    // Convert suggestions to tasks
    const tasks = [];
    for (const suggestion of aiSuggestions.suggestions) {
      const task = await this.createTask(
        projectId,
        suggestion.title,
        suggestion.description,
        suggestion.priority || TaskPriority.MEDIUM,
        suggestion.type || TaskType.FEATURE,
        {
          source: 'ai_analysis',
          projectPath,
          analysisId: projectAnalysis.id
        }
      );
      tasks.push(task);
    }

    return {
      projectId,
      projectPath,
      analysis: projectAnalysis,
      tasks,
      aiSuggestions,
      timestamp: new Date()
    };
  }

  /**
   * Get project analysis
   * @param {string} analysisId - Analysis ID
   * @returns {Promise<Object>} Analysis results
   */
  async getProjectAnalysis(analysisId) {
    // Mock implementation - in real implementation this would fetch from database
    return {
      id: analysisId,
      projectType: 'nodejs',
      complexity: 'medium',
      issues: [],
      suggestions: []
    };
  }

  /**
   * Execute auto mode for a project
   * @param {string} projectId - Project ID
   * @param {string} projectPath - Project path
   * @param {Object} options - Auto mode options
   * @returns {Promise<Object>} Auto mode results
   */
  async executeAutoMode(projectId, projectPath, options = {}) {
    // Mock implementation - in real implementation this would:
    // 1. Analyze project
    // 2. Generate tasks
    // 3. Execute tasks automatically
    // 4. Monitor progress
    // 5. Generate reports

    return {
      projectId,
      projectPath,
      status: 'running',
      tasksGenerated: 5,
      tasksCompleted: 0,
      startedAt: new Date()
    };
  }

  /**
   * Get auto mode status
   * @param {string} projectId - Project ID
   * @returns {Promise<Object>} Auto mode status
   */
  async getAutoModeStatus(projectId) {
    // Mock implementation
    return {
      projectId,
      status: 'idle',
      lastRun: null,
      totalRuns: 0
    };
  }

  /**
   * Stop auto mode
   * @param {string} projectId - Project ID
   * @returns {Promise<boolean>} Success status
   */
  async stopAutoMode(projectId) {
    // Mock implementation
    return true;
  }

  /**
   * Generate script for a task
   * @param {string} projectId - Project ID
   * @param {string} taskId - Task ID
   * @param {Object} context - Project context
   * @param {Object} options - Generation options
   * @returns {Promise<Object>} Generated script
   */
  async generateScript(projectId, taskId, context, options = {}) {
    const task = await this.taskRepository.findById(taskId);
    if (!task || !task.belongsToProject(projectId)) {
      throw new Error('Task not found or does not belong to project');
    }

    return await this.aiService.generateScript(task, context, options);
  }

  /**
   * Get generated scripts for a project
   * @param {string} projectId - Project ID
   * @returns {Promise<Array>} Generated scripts
   */
  async getGeneratedScripts(projectId) {
    // Mock implementation
    return [];
  }

  /**
   * Execute script for a project
   * @param {string} projectId - Project ID
   * @param {string} scriptId - Script ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} Execution result
   */
  async executeScript(projectId, scriptId, userId) {
    // Mock implementation
    return {
      scriptId,
      projectId,
      userId,
      status: 'completed',
      result: 'Script executed successfully'
    };
  }
}

module.exports = TaskService; 